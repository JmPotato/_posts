#Tornado中render()固定全局变量

-tags:Python, Tornado

----

声明：后来 whtsky 告诉我这是舍近求远的办法，大家不要学，被我带坑里概不负责。

最近开发的时候，把模板系统从jinja2换到了Tornado自带的，一换还真有点不习惯，十分不顺手。

我在`layout.html`定义了几个固定变量：

* blog_name
* blog_url

无奈每次render基于`layout.html`的模板时，都要附加上这两个变量，很麻烦，而且写出来的东西看起来也很冗长。
于是决定研究一下Tornado渲染模板时的工作方法，基于这个进行改造。
首先来看看render方法的源码：

```python
def render(self, template_name, **kwargs):
    """Renders the template with the given arguments as the response."""
    html = self.render_string(template_name, **kwargs)

    # Insert the additional JS and CSS added by the modules on the page
    js_embed = []
    js_files = []
    css_embed = []
    css_files = []
    html_heads = []
    html_bodies = []
    for module in getattr(self, "_active_modules", {}).values():
        embed_part = module.embedded_javascript()
        if embed_part:
            js_embed.append(utf8(embed_part))
        file_part = module.javascript_files()
        if file_part:
            if isinstance(file_part, (unicode_type, bytes_type)):
                js_files.append(file_part)
            else:
                js_files.extend(file_part)
        embed_part = module.embedded_css()
        if embed_part:
            css_embed.append(utf8(embed_part))
        file_part = module.css_files()
        if file_part:
            if isinstance(file_part, (unicode_type, bytes_type)):
                css_files.append(file_part)
            else:
                css_files.extend(file_part)
        head_part = module.html_head()
        if head_part:
            html_heads.append(utf8(head_part))
        body_part = module.html_body()
        if body_part:
            html_bodies.append(utf8(body_part))
````

发现render()主要依赖于render_string()工作，于是找到render_string()

```python
def render_string(self, template_name, **kwargs):
    """Generate the given template with the given arguments.

    We return the generated byte string (in utf8). To generate and
    write a template as a response, use render() above.
    """
    # If no template_path is specified, use the path of the calling file
    template_path = self.get_template_path()
    if not template_path:
        frame = sys._getframe(0)
        web_file = frame.f_code.co_filename
        while frame.f_code.co_filename == web_file:
            frame = frame.f_back
        template_path = os.path.dirname(frame.f_code.co_filename)
    with RequestHandler._template_loader_lock:
        if template_path not in RequestHandler._template_loaders:
            loader = self.create_template_loader(template_path)
            RequestHandler._template_loaders[template_path] = loader
        else:
            loader = RequestHandler._template_loaders[template_path]
    t = loader.load(template_name)
    namespace = self.get_template_namespace()
    namespace.update(kwargs)
    return t.generate(**namespace)
```

倒数第二行是`namespace.update(kwargs)`，把要渲染的变量传入到模板中去，我们可以在这个部分下手，进行改造。
首先，需要将两个固定的变量传进去，想了想，放在Tornado的settings作为一个全局变量再合适不过了，方便修改和取用。
只要在Application的__init___中，在settings里面加入`blog_name`和`blog_url`两个变量即可。
可是要怎么调用他俩呢？我突然想到了Tornado的一个装饰器
`@tornado.web.authenticated`
它的源码里面肯定有调用settings里的`login_url`的代码，查找过后，果然有一个`self.application.settings["login_url"]`
这下我们就可以开始重写render_string()啦

```python
import tornado.web

class BaseHandler(tornado.web.RequestHandler):
    def render_string(self, template_name, title, **kwargs):
        base_value = dict(
            blog_url = self.application.settings["blog_url"],
            blog_name = self.application.settings["blog_name"],
            )
        template_path = self.get_template_path()
        if not template_path:
            frame = sys._getframe(0)
            web_file = frame.f_code.co_filename
            while frame.f_code.co_filename == web_file:
                frame = frame.f_back
            template_path = os.path.dirname(frame.f_code.co_filename)
        with tornado.web.RequestHandler._template_loader_lock:
            if template_path not in tornado.web.RequestHandler._template_loaders:
                loader = self.create_template_loader(template_path)
                tornado.web.RequestHandler._template_loaders[template_path] = loader
            else:
                loader = tornado.web.RequestHandler._template_loaders[template_path]
        t = loader.load(template_name)
        namespace = self.get_template_namespace()
        namespace.update(kwargs)
        namespace.update(base_value)
        return t.generate(**namespace)

```

ok，大功告成，我们又可以愉悦的和render()玩耍了~
